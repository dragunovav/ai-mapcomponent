<!DOCTYPE html>
<html>
  <head>
    <title>App Inventor - Map Component</title>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no">
    <meta charset="utf-8">
    <style>
      html, body, #map-canvas {
        height: 100%;
        margin: 0px;
        padding: 0px
      }
    </style>
    <!-- TODO (jos) take the API_KEY out of the String and as a property -->
    <script src="https://maps.googleapis.com/maps/api/js?v=3.exp"></script>
    <script>
      /**
       * This map script is an abstraction of a number of functions from the Google maps
       * JavaScript API to be used within a customized WebView as an App Inventor Component.
       *
       * It contains two main objects: thisMap and mapMarkers.
       * thisMap initializes the map and makes user of mapMarkers, which simply encapsulates all
       * functions related to markers placed in the map. It is possible to create other utility
       * objects with other functionality in the SDK such as drawing, layers, or services.
       */

      /**
       * This function returns an object with certain methods exposed as its API. The functionality
       * of this object is related to management of markers in the map.
       * @param map the map that all the methods in this object will be associated with.
       * @returns {{addMarker: addMarker, addMarkersFromList: addMarkersFromList,
       * addListenersUserMarkers: addListenersUserMarkers, showUserMarkers: showUserMarkers,
       * hideUserMarkers: hideUserMarkers, deleteUserMarkers: deleteUserMarkers}}
       */
      var mapMarkers = function(map) {

        if (!mapComponent) throw new Error('No map available');

        //TODO (jos) abandon the idea of user vs dev markers; they are all user markers.
        var markers = [];
        var markerCounter = -1;

        var addMarker = function (location, title, infoWindowContent) {
          if (location instanceof google.maps.LatLng){
            var marker = new google.maps.Marker({
              id: markerCounter+=1,
              position: location,
              animation: google.maps.Animation.DROP,
              title: title || '',
              map: mapComponent
            });
            google.maps.event.addListener(marker, 'click', markerClicked(markerCounter));
            markers[markerCounter] = marker;

            if (infoWindowContent) {
              createInfoWindow(markerCounter, infoWindowContent);
            }
          }
          else {
            console.log('Calling Error handler on Android side');
            androidObject.dispatchErrorToAndroid(androidObject.ERROR_ILLEGAL_COORDS_FORMAT);
          }
        };

        // Closure needed to associate each markerId with its click handler function
        function markerClicked(markerId) {
          return function(){
            handleMarkerById(markerId);
          }
        }

        function handleMarkerById(markerId) {
          console.log('Signaling Android side to do something with marker ' + markerId);
          androidObject.sendMarkerToAndroid(markerId);
        };

        function hideMarker(markerId) {
          if (markers[markerId])
            markers[markerId].setMap(null);
        };

        //TODO (jos) this function has to change now to take care of title and infoWindow
        function addMarkersFromList(listOfMarkers){
          listOfMarkers.forEach(function(marker) { addMarker(marker); });
        }

        function addListenersUserMarkers(add) {
          if (add){
            google.maps.event.addListener(mapComponent, 'click', function(event) {
              addMarker(event.latLng);
            });
          }
          else
            google.maps.event.clearListeners(mapComponent,'click');
        }

        //TODO (jos) on Android, if markers = [] I could show a Toast - Also on delete functions.
        function showUserMarkers(){
          markers.forEach(function(marker) { marker.setMap(mapComponent); });
        }

        function hideUserMarkers(){
          markers.forEach(function(marker) { marker.setMap(null); });
        }

        function deleteUserMarkers(){
          hideUserMarkers();
          markers = [];
          markerCounter = -1;
        }

        var storeMarkers = function () {
          var allMarkers = [];
          markers.forEach(function(marker){

            var mark = {};
            mark.id = marker.id; //Are we going to need ids? recreate when load from list?
            mark.lat = marker.getPosition().lat();
            mark.lng = marker.getPosition().lng();
            if (marker.title)
              mark.title = marker.title;
            if (marker.info)
              mark.content = marker.info.content;

            allMarkers.push(mark);
          });

          return allMarkers;
        };

        //Geolocation service
        function geolocate(address){
          var geocoder = new google.maps.Geocoder();
          geocoder.geocode({address: address}, geolocationResults)
        }

        //TODO (jos) explicit Exception handling for results will be done in the Android side
        var geolocationResults = function(results, status){
          if (status === 'OK') {
            var firstLocationFound = results[0].geometry.location;
            if (firstLocationFound){
              console.log(firstLocationFound);
              addMarker(firstLocationFound);
              map.panTo(firstLocationFound);
            }
            else {
              console.log('No location found!');
            }
          }
          else if (status === "ZERO_RESULTS"){
            console.log('No results found for that particular address.');
          }
          else {
            console.log('No results found. Status of Gelocation call: ' + status);
          }
        }

        // InfoWindow functions
        var createInfoWindow = function(markerId, content) {
          var infoWindow = new google.maps.InfoWindow({
            content: content
          });
          var marker = markers[markerId];
          if (marker)
            marker.info = infoWindow;
        };

        var openInfoWindow = function(markerId){
          var marker = markers[markerId];
          if (marker && marker.info)
            marker.info.open(map, marker)
        }

        //API for the mapMarkers object
        return {
          addMarker: addMarker,
          addMarkersFromList: addMarkersFromList,
          addListenersUserMarkers: addListenersUserMarkers,
          showUserMarkers: showUserMarkers,
          hideUserMarkers: hideUserMarkers,
          deleteUserMarkers: deleteUserMarkers,
          storeMarkers: storeMarkers,
          geolocate: geolocate,
          hideMarker: hideMarker,
          userMarkers: markers,
          createInfoWindow: createInfoWindow,
          openInfoWindow: openInfoWindow
        };

      };


      /**
       * Main function for this script. Initializes the map and all the related functionality.
       *
       */
      var thisMap = function(centerLat, centerLng, showCenter){
      
        var map;
        var center;
        var markerFunctions;
        var initialZoom = 8;
        function initialize() {
          var mapOptions = {
            zoom: initialZoom,
            center: new google.maps.LatLng(centerLat, centerLng)
          };
          mapComponent = new google.maps.Map(document.getElementById('map-canvas'), mapOptions);

          center = createCenter();

          showMarker(showCenter);

          //Initialize marker functions object
          markerFunctions = mapMarkers(mapComponent);
          
        }

        var createCenter = function(){
          var center;
          if (mapComponent && mapComponent.getCenter()){
              center = new google.maps.Marker({
                position: mapComponent.getCenter(),
                map: mapComponent,
                title: 'Map Center',
                icon: {
                  path: google.maps.SymbolPath.CIRCLE,
                  scale: 6
                }
              });
          }
          return center;
        };

        // Special case of showing a marker only for the center. Might be possible to abstract in
        // markerFunctions, but leaving it here for now (jos).
        var showMarker = function(show){
          if (show){
            if (center)
              center.setMap(mapComponent);
            else
              center = createCenter();
          }
          else
            center.setMap(null);
        };

        var getMap = function() { return mapComponent; };
        var getMarkerFunctions = function() { return markerFunctions; };

        var setZoom = function(zoom) {
          if (zoom >= 0 && zoom <= 19){
            mapComponent.setZoom(zoom);
          }
          else //TODO (jos) Exception handling on Android side
            console.log('Zoom value ' + zoom + ' is not in the valid range 0-19');
        };

        var getZoom = function() { return mapComponent.zoom; };

        /**
         * Generates a LatLng map object from coordinates passed in as a string. Valid ranges are:
         * Lat [-90, 90], and Lng [-180, 180].
         * @param locationText a string in the format 'float, float'
         * @returns {*} a LatLng object of null if the location is not in the right format.
         */
        var locationFromTextCoords = function(locationText) {
          var lat, lng;
          var errorParsing = false;

          var locationSplit = locationText.split(',');
          if (locationSplit.length === 2){
            lat = parseFloat(locationSplit[0]);
            lng = parseFloat(locationSplit[1]);
            if (isNaN(lat) || isNaN(lng))
              errorParsing = true;
            if (lat < -90 || lat > 90) errorParsing = true;
            if (lng < -180 || lng > 180) errorParsing = true;
          }
          else {
            errorParsing = true;
          }

          if (errorParsing){
            androidObject.dispatchErrorToAndroid(androidObject.ERROR_ILLEGAL_COORDS_FORMAT);
            return null;
          }
          else
            return new google.maps.LatLng(lat, lng);
        };

        //API for the thisMap object: main entry object for functionality
        return {
          initialize: initialize,
          showCenter: showMarker,
          getMap: getMap, //TODO (jos) Do I need to expose the map?
          getMarkerFunctions: getMarkerFunctions,
          setZoom: setZoom,
          getZoom: getZoom,
          locationFromTextCoords: locationFromTextCoords
        }
      //TODO (jos) Magic numbers: the center of the map has to be a variable. Will come from Android
      }(-34.397, 150.644, true); //Auto initialize the thisMap object

      //TODO (jos) Can I somehow inject this object (or inject something in this object) to
      // handle user feedback also on the JavaScript side?
      var androidObject = {

        // CONSTANTS FOR ERRORS
        ERROR_ILLEGAL_COORDS_FORMAT: 2502, // As defined on the Android side.

        /**
         * Function to dispatch errors to Android through the AppInventorMap interface. If this
         * file is loaded on a browser, AppInventorMap will be undefined and we skip the
         * dispatching.
         * TODO (jos) think about Error handling in JS if I even want to use this file standalone.
         * @param errorNumber number for the message to display as user feedback on the Android
         * side. The messages are defined in ErrorMessages.java
         */
        dispatchErrorToAndroid: function(errorNumber) {
          if (typeof AppInventorMap !== 'undefined')
            AppInventorMap.dispatchError(errorNumber);
        },

        /**
         * Function to call to the Android side after a user has clicked on a marker
         */
        sendMarkerToAndroid: function(markerId) {
          if (typeof AppInventorMap !== 'undefined')
            AppInventorMap.handleMarker(markerId);
        }

      };

      google.maps.event.addDomListener(window, 'load', thisMap.initialize);

    </script>
  </head>
  <body>
    <div id="map-canvas"></div>
  </body>
</html>
